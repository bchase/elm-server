#!/usr/bin/env node

const _ = require('lodash')
const http = require('http')
const url = require('url')
const qs = require('query-string')

const Elm  = require('./elm.js')


const port = 8080

const config = { env: 'dev' }

// // url.parse("/hi?foo=bar&baz=boo#qux")
// Url {
//   protocol: null,
//   slashes: null,
//   auth: null,
//   host: null,
//   port: null,
//   hostname: null,
//   hash: '#qux',
//   search: '?foo=bar&baz=boo',
//   query: 'foo=bar&baz=boo',
//   pathname: '/hi',
//   path: '/hi?foo=bar&baz=boo',
//   href: '/hi?foo=bar&baz=boo#qux' }
const server = function(req, body, callback) {
  const buildConn = (cfg, rawReq) => {
    const { headers, method } = rawReq
    const { pathname, query } = url.parse(rawReq.url)

    const req = { headers: _.toPairs(headers), method, pathname, queryParams: _.toPairs(qs.parse(query)), body }

    return { cfg, req }
  }

  const elm = Elm.Main.worker(buildConn(config, req))
  elm.ports.exit.subscribe(callback)
}



// https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/
http.createServer((req, resp) => {
  const error = (err) => { console.error(err) } // TODO

  let body = []
  req
    .on('error', error)
    .on('data', (chunk) => { body.push(chunk) })
    .on('end', () => {
      body = Buffer.concat(body).toString()
      resp.on('error', error)
      server(req, body, ({success, payload}) => {
        if (!success) {
          error(payload)
        } else {
          const output = {
            status: 200,
            headers: { 'Content-Type': 'application/json' },
            body: payload,
          }

          resp.writeHead(output.status, output.headers)
          resp.end(output.body)
        }
      })
    })
}).listen(port)
